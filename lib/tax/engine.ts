import { prisma } from "@/lib/prisma";
import { getParam } from "./parameters";
const clamp=(n:number,lo:number,hi:number)=>Math.max(lo,Math.min(hi,n));
function piecewise(amount:number,br:{from:number;to:number;rate:number}[]){ let t=0; for(const b of br){ const base=Math.max(0,Math.min(amount,b.to)-b.from); if(base>0) t+=base*b.rate; if(amount<=b.to) break; } return t; }
function currency(n:number){ return Math.round(n*100)/100; }
function splitIncome(incomes:{type:string|null,amount:number}[]){ let employeeY=0,zzpY=0,dividendY=0; for(const i of incomes){ const y=i.amount*12; const t=(i.type||"").toLowerCase(); if(t.includes("dividend")) dividendY+=y; else if(t.includes("zzp")||t.includes("business")||t.includes("onderneming")) zzpY+=y; else employeeY+=y; } return { employeeY, zzpY, dividendY }; }
function splitExpenses(expenses:{category:string|null,amount:number,name:string}[]){ let businessY=0,mortgageInterestY=0; for(const e of expenses){ const y=e.amount*12; const c=(e.category||"").toLowerCase(); const n=(e.name||"").toLowerCase(); if(c.includes("business")||c.includes("zakelijk")) businessY+=y; if(c.includes("mortgage")||c.includes("hypotheek")||n.includes("hypotheekrente")) mortgageInterestY+=y; } return { businessY, mortgageInterestY }; }
async function eigenWoningForfait(userId:string,year:number){ const table=await getParam<{from:number;to:number;rate:number}[]>("Eigenwoningforfait",year); const home=await prisma.asset.findFirst({ where:{ userId, type:{ contains:"Real Estate" } }, orderBy:{ createdAt:"asc" } }); if(!home) return { ewfBase:0, ewf:0 }; const base=home.value; let ewf=0; for(const b of table){ const part=Math.max(0,Math.min(base,b.to)-b.from); if(part>0) ewf+=part*b.rate; if(base<=b.to) break; } return { ewfBase:base, ewf }; }
export async function calc_box1_tax(userId:string,year:number){ const person=await prisma.person.findFirst({ where:{ userId } }); const incomes=await prisma.income.findMany({ where:{ userId } }); const expenses=await prisma.expense.findMany({ where:{ userId } }); const { employeeY, zzpY }=splitIncome(incomes as any); const { businessY, mortgageInterestY }=splitExpenses(expenses as any); const { ewfBase, ewf }=await eigenWoningForfait(userId,year); const zzpProfitGross=Math.max(0,zzpY-businessY); const zelfstandigenaftrek=await getParam<number>("Zelfstandigenaftrek",year).catch(()=>0); const startersaftrek=await getParam<number>("Startersaftrek",year).catch(()=>0); const mkbVrij=await getParam<number>("Mkb_winstvrijstelling",year).catch(()=>0.14); const hraCap=await getParam<number>("Hypotheekrenteaftrek_max",year).catch(()=>0.367); const isZZP=zzpY>0; const hasStarter=false; let zzpAfterDed=zzpProfitGross; if(isZZP){ zzpAfterDed-=clamp(zelfstandigenaftrek,0,zzpAfterDed); if(hasStarter) zzpAfterDed-=clamp(startersaftrek,0,zzpAfterDed); zzpAfterDed=Math.max(0,zzpAfterDed); const mkb=zzpAfterDed*mkbVrij; zzpAfterDed=Math.max(0,zzpAfterDed-mkb); } const brackets=await getParam<any>(person?.aow?"IB_box1_schijven_AOW":"IB_box1_schijven",year); const taxableNoHRA=employeeY+zzpAfterDed+ewf; const tax_noHRA=piecewise(taxableNoHRA,brackets); const taxableFull=Math.max(0,taxableNoHRA-mortgageInterestY); const tax_fullDed=piecewise(taxableFull,brackets); const fullRelief=tax_noHRA-tax_fullDed; const cappedRelief=Math.min(fullRelief,mortgageInterestY*hraCap); const box1_tax=currency(tax_noHRA-cappedRelief); const taxable_box1=Math.max(0,taxableNoHRA-mortgageInterestY); await prisma.taxYearCalc.upsert({ where:{ userId_year:{ userId,year } }, update:{ taxable_box1, box1_tax, breakdown:{ employeeY, zzpY, zzpProfitGross, businessY, zzpAfterDed, ewfBase, ewf, mortgageInterestY, hraCap, tax_noHRA, fullRelief, cappedRelief, brackets } as any }, create:{ userId, year, taxable_box1, box1_tax, breakdown:{ employeeY, zzpY, zzpProfitGross, businessY, zzpAfterDed, ewfBase, ewf, mortgageInterestY, hraCap, tax_noHRA, fullRelief, cappedRelief, brackets } as any } }); return box1_tax; }
export async function calc_zvw(userId:string,year:number){ const incomes=await prisma.income.findMany({ where:{ userId } }); const { employeeY, zzpY }=splitIncome(incomes as any); const paramEmp=await getParam<any>("Zvw_werknemer",year); const paramZZP=await getParam<any>("Zvw_zelfstandig",year); const baseEmp=Math.min(paramEmp.max_income,employeeY); const baseZZP=Math.min(paramZZP.max_income,zzpY); const amount=baseEmp*paramEmp.rate + baseZZP*paramZZP.rate; await prisma.taxYearCalc.upsert({ where:{ userId_year:{ userId,year } }, update:{ zvw:amount }, create:{ userId, year, zvw:amount } }); return amount; }
export async function calc_heffingskortingen(userId:string,year:number){ const alg=await getParam<any>("Heffingskorting_algemeen",year); const arb=await getParam<any>("Heffingskorting_arbeid",year); const incomes=await prisma.income.findMany({ where:{ userId } }); const { employeeY, zzpY }=splitIncome(incomes as any); const income=employeeY+zzpY; const algemene=clamp(alg.max - Math.max(0,income - alg.afbouw_start)*alg.afbouw_rate, 0, alg.max); const arbeids=clamp(Math.min(arb.max, income*arb.opbouw) - Math.max(0, income - arb.afbouw_start)*arb.afbouw_rate, 0, arb.max); const kortingen={ algemene:currency(algemene), arbeids:currency(arbeids) }; await prisma.taxYearCalc.upsert({ where:{ userId_year:{ userId,year } }, update:{ heffingskortingen: kortingen as any }, create:{ userId, year, heffingskortingen: kortingen as any } }); return kortingen; }
export async function calc_box2_tax(userId:string,year:number){ const brackets=await getParam<any>("Box2_tarief",year); const incomes=await prisma.income.findMany({ where:{ userId } }); const dividendY=incomes.filter(i=>(i.type||"").toLowerCase().includes("dividend")).reduce((a,i)=>a+i.amount*12,0); const gross=piecewise(dividendY,brackets); const withhold=await getParam<number>("Dividendbelasting",year).catch(()=>0.15); const net=Math.max(0,gross - dividendY*withhold); await prisma.taxYearCalc.upsert({ where:{ userId_year:{ userId,year } }, update:{ box2_tax:currency(net) }, create:{ userId, year, box2_tax:currency(net) } }); return currency(net); }
export async function calc_box3_tax(userId:string,year:number){ const vrij=await getParam<number>("Box3_vrijstelling_per_persoon",year); const forfait=await getParam<any>("Box3_forfait",year); const tarief=await getParam<number>("Box3_tarief",year); const assets=await prisma.asset.findMany({ where:{ userId } }); const spaargeld=assets.filter(a=>a.type.includes("Cash")).reduce((a,b)=>a+b.value,0); const overig=assets.filter(a=>!a.type.includes("Cash")).reduce((a,b)=>a+b.value,0); const persons=await prisma.person.findMany({ where:{ userId } }); const allowance=vrij * Math.max(1, Math.min(2, persons.length)); const fict=Math.max(0,spaargeld-allowance)*forfait.spaargeld + Math.max(0, overig - Math.max(0, allowance-spaargeld))*forfait.overig; const tax=currency(fict*tarief); await prisma.taxYearCalc.upsert({ where:{ userId_year:{ userId,year } }, update:{ box3_tax:tax }, create:{ userId, year, box3_tax:tax } }); return tax; }
export async function combine_tax_year(userId:string,year:number){ const [box1,zvw,kort,box2,box3]=await Promise.all([ calc_box1_tax(userId,year), calc_zvw(userId,year), calc_heffingskortingen(userId,year), calc_box2_tax(userId,year), calc_box3_tax(userId,year) ]); const incomes=await prisma.income.findMany({ where:{ userId } }); const expenses=await prisma.expense.findMany({ where:{ userId } }); const grossY=incomes.reduce((a,i)=>a+i.amount*12,0); const expY=expenses.reduce((a,e)=>a+e.amount*12,0); const kortingSum=Object.values(kort).reduce((a:any,b:any)=>a+Number(b||0),0); const totalTax=Math.max(0, box1+zvw+box2+box3 - kortingSum); const nbi=currency(grossY - expY - totalTax); const breakdown={ ...(await prisma.taxYearCalc.findUnique({ where:{ userId_year:{ userId,year } } }))?.breakdown, grossY, expY, totalTax, nbi, kortingen: kort }; await prisma.taxYearCalc.upsert({ where:{ userId_year:{ userId,year } }, update:{ netto_bestede_inkomen:nbi, breakdown }, create:{ userId, year, netto_bestede_inkomen:nbi, breakdown } }); return { year, grossY, expY, totalTax, nbi } as any; }
